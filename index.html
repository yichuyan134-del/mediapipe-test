<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini 手势控制 - 手机浏览器版</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.min.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 0;
            background-color: #1a1a2e; /* 深色背景，模拟贾维斯风格 */
            color: #4CAF50;
        }
        #webcam {
            /* 摄像头视频流，设置为隐藏或小尺寸，因为我们主要在 canvas 上显示 */
            display: none;
            /* width: 100%;
            height: auto; */
        }
        #output_canvas {
            /* 绘制结果的画布，占据屏幕主体 */
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            border: 2px solid #4CAF50;
            transform: scaleX(-1); /* 镜像翻转，使手势更自然 */
        }
        .info {
            position: fixed;
            bottom: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            z-index: 20;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <video id="webcam" playsinline></video>

    <canvas id="output_canvas"></canvas>

    <div class="info">
        <p>状态: <span id="status">正在加载...</span></p>
        <p>左手捏合控制地球大小 (Y轴)</p>
        <p>地球半径: <span id="radius_display">50</span></p>
    </div>

    <script>
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const statusDisplay = document.getElementById('status');
        const radiusDisplay = document.getElementById('radius_display');

        // --- 核心配置 ---
        const MIN_RADIUS = 30;
        const MAX_RADIUS = 250;
        const PINCH_THRESHOLD = 0.05; // 捏合距离阈值 (基于归一化坐标 0-1)
        let earthRadius = 50;
        let earthCenter = { x: 0, y: 0 };
        const SMOOTHING_FACTOR = 0.1; // 平滑因子，使半径变化更自然

        // --- 设置画布大小为全屏 ---
        function setCanvasSize() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
            earthCenter = { x: canvasElement.width / 2, y: canvasElement.height / 2 };
        }
        window.addEventListener('resize', setCanvasSize);
        setCanvasSize();

        // --- 核心功能：处理手势 ---
        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // 绘制地球
            drawEarth();

            // 绘制手部骨架
            if (results.multiHandLandmarks) {
                let leftHandDetected = false;

                for (const hand of results.multiHandLandmarks) {
                    // MediaPipe 提供了左右手信息，但需要手动关联
                    const handLabel = results.multiHandedness[results.multiHandLandmarks.indexOf(hand)].classification[0].label;

                    // 绘制手部骨架 (颜色调整为贾维斯风格的绿色)
                    mpHands.drawConnectors(canvasCtx, hand, mpHands.HAND_CONNECTIONS,
                                        {color: '#00FF00', lineWidth: 5});
                    mpHands.drawLandmarks(canvasCtx, hand, {color: '#FFFFFF', lineWidth: 2});

                    if (handLabel === 'Left') {
                        leftHandDetected = true;
                        
                        // 获取拇指尖 (4) 和食指尖 (8) 的归一化坐标
                        const thumbTip = hand[mpHands.HandLandmark.THUMB_TIP];
                        const indexTip = hand[mpHands.HandLandmark.INDEX_FINGER_TIP];

                        // 计算捏合距离 (归一化距离)
                        const distance = Math.sqrt(
                            Math.pow(thumbTip.x - indexTip.x, 2) + 
                            Math.pow(thumbTip.y - indexTip.y, 2)
                        );
                        
                        let targetRadius = earthRadius;
                        let gestureStatus = "左手打开";

                        if (distance < PINCH_THRESHOLD) {
                            // --- 识别到捏合手势 ---
                            gestureStatus = "左手捏合 (Y轴控制)";
                            
                            // 使用手的 Y 坐标来控制半径 (Y轴从上到下为 0 到 1)
                            // 目标：手越靠近屏幕上方 (Y 越小)，地球越小 (靠近 MIN_RADIUS)
                            // 手越靠近屏幕下方 (Y 越大)，地球越大 (靠近 MAX_RADIUS)
                            
                            // Y轴取拇指尖的Y坐标
                            const normalizedY = thumbTip.y; 
                            
                            // 将 Y 坐标映射到半径范围 [MIN_RADIUS, MAX_RADIUS]
                            // targetRadius = MIN_RADIUS + (normalizedY * (MAX_RADIUS - MIN_RADIUS));
                            
                            // 调整：Y轴越小（顶部），半径越小；Y轴越大（底部），半径越大
                            targetRadius = MIN_RADIUS + normalizedY * (MAX_RADIUS - MIN_RADIUS);
                            
                            // 平滑处理 (使变化更流畅)
                            earthRadius += (targetRadius - earthRadius) * SMOOTHING_FACTOR;
                            earthRadius = Math.min(Math.max(earthRadius, MIN_RADIUS), MAX_RADIUS); // 限制范围

                        }
                        
                        // 显示手势状态
                        canvasCtx.fillStyle = '#FFFFFF';
                        canvasCtx.font = '20px Arial';
                        canvasCtx.fillText(gestureStatus, 20, 30);
                    }
                }
            } else {
                canvasCtx.fillStyle = '#FF0000';
                canvasCtx.font = '20px Arial';
                canvasCtx.fillText("未检测到手部", 20, 30);
            }

            // 更新显示信息
            statusDisplay.textContent = leftHandDetected ? "追踪中" : "等待手部...";
            radiusDisplay.textContent = Math.round(earthRadius);

            canvasCtx.restore();
        }

        // --- 绘制虚拟地球 ---
        function drawEarth() {
            canvasCtx.beginPath();
            // 绘制地球圆
            canvasCtx.arc(earthCenter.x, earthCenter.y, earthRadius, 0, 2 * Math.PI);
            canvasCtx.fillStyle = '#0066cc'; // 地球颜色
            canvasCtx.fill();

            // 绘制白色边框
            canvasCtx.strokeStyle = '#FFFFFF';
            canvasCtx.lineWidth = 3;
            canvasCtx.stroke();
            
            // 绘制大小文本
            canvasCtx.fillStyle = '#FFFFFF';
            canvasCtx.font = 'bold 18px Arial';
            canvasCtx.textAlign = 'center';
            canvasCtx.fillText(`大小: ${Math.round(earthRadius)}`, earthCenter.x, earthCenter.y + earthRadius + 25);
        }
        
        // --- 启动 MediaPipe 和摄像头 ---
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1, // 模型复杂度，0是最低，2是最高。手机上建议使用 1 或 0
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // 使用 @mediapipe/camera_utils 来启动摄像头
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });

        camera.start().then(() => {
            statusDisplay.textContent = "已就绪，请将左手对准摄像头";
        }).catch(error => {
            statusDisplay.textContent = `启动摄像头失败: ${error.name}`;
            console.error("Camera startup failed:", error);
        });

        // 引入 Camera Utils (用于启动摄像头)
        // 注意：这里需要加载 CameraUtils 库
        const cameraUtilsScript = document.createElement('script');
        cameraUtilsScript.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js';
        document.head.appendChild(cameraUtilsScript);
        
    </script>
</body>
</html>
